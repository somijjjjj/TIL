# 리스트(list)

리스트는 데이터 구조의 하나로, 데이터를 일직선으로 나열한 형태를 가지고 있다.  
데이터 추가나 삭제는 쉽지만, 원하는 데이터에 접근하려면 시간이 많이 걸린다.  

- 리스트의 개념도
![](https://velog.velcdn.com/images/silver0/post/eeb06396-444a-43ea-8e13-e6ab5460ec68/image.png)

세 개의 문자열 'Blue','Yellow','Red'가 데이터로 저장되어 있다.  
각 데이터에는 '포인터(pointer)'가 있으며, 다음 데이터의 메모리 위치를 가리킨다.  
'Red'는 마지막 데이터이므로 'Red'포인터는 아무것도 가리키지 않는다.  

리스트에서 데이터가 메모리상의 연속된 위치에 저장되지 않아도 되며,  
일반적으로 떨어진 영역에 흩어져서 저장된다.  

### 순차접근
흩어져 저장돼 있으므로 포인터를 처음부터 순서대로 따라가야만 원하는 데이터에 접근할 수 있다.
- 이것을 '순차 접근' 또는 '시퀀셜 액세스(sequential access)'라고 한다.  
예를 들어, 'Red'에 접근하고 싶은경우는 먼저 'Blue'에 접근한 뒤 'Yellow'를 가야만 'Red'에 접근할 수 있다.

### 데이터 추가
추가할 위치의 앞 뒤 포인터를 변경만 하면 되므로 간단하다고 볼 수 있다.  
예를 들어, 'Blue'와 'Yellow' 사이에 'Green'을 추가하고 싶을 때  
'Blue'의 포인터를 'Green'을 가리키도록 변경하고, 'Green'포인터를 'Yellow'를 가리키도록 하면 된다.  

![](https://velog.velcdn.com/images/silver0/post/68f19ca0-db74-4c73-aba6-5480cba6f786/image.png)

### 데이터 삭제
데이터 추가와 같은 방식으로 포인터의 방향을 바꾸면 된다.  
예를 들어, 'Yellow'를 삭제하는 경우  
'Green' 포인터를 'Yellow'가 아닌 'Red'로 변경하면 삭제가 완료된다.  

![](https://velog.velcdn.com/images/silver0/post/702f842b-0a32-49ce-9076-aed840a06754/image.png)

'Yellow'는 메모리에는 남지만 어디에서도 접근할 수 없으므로 일부러 삭제할 필요는 없고
이후에 이 영역이 사용될 때 덮어쓰기가 되어 다시 사용할 수 있게 된다.  

### 계산 시간
리스트에 저장되어 있는 데이터 수가 n이라면, 데이터에 접근할 때에는 리스트의 앞에서부터 차례로 진행하기 때문에(선형 탐색) 접근하고 싶은 데이터가 뒤쪽에 있는 경우에는 O(n)의 계산 시간이 걸린다.  
반면, 데이터 추가와 삭제는 해당 위치에 이미 접근해 있는 것을 전제로 두 개의 포인터만 변경하면 되기에 n에 상관없는 상수 시간 O(1)이 된다.  

### 원형 리스트와 양방향 리스트

- 원형 리스트
   - ![](https://velog.velcdn.com/images/silver0/post/e1f391e2-ca59-46ba-b52e-4cbb0b8a6791/image.png)
   
마지막 데이터 포인터가 선두를 가리키도록 하면 원형으로 연결이 된다.  
이것을 '원형 리스트' 또는 '순환 리스트'라고 한다.  
원형 리스트에는 선두나 후미라는 개념이 없다.  

- 양방향 리스트
   - ![](https://velog.velcdn.com/images/silver0/post/700fcda4-625b-481a-865f-19e75b093255/image.png)
   
각 데이터가 포인터 두 개를 사용해서 앞뒤 데이터를 가리키도록 한 '양방향 리스트'가 있다.  
리스트를 앞에서 뒤로, 뒤에서 앞으로도 추적할 수 있게 하여 편리하다.  
단, 양방향 리스트에서는 포인터 수가 늘어나므로 데이터 저장을 위한 영역이 많아지는 결점이 있다.  
또한 데이터 추가나 삭제 시에도 변경해야 할 포인터가 늘어난다.  


---

<br>
<br>

> Reference
> - 『알고리즘 도감』, 이시다 모리테루, 미야자키 쇼이치 - 제이펍