# 재귀함수

[참고]  
https://namu.wiki/w/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98


재귀함수는 정의 단계에서 자신을 재참조하는 함수를 뜻한다.

어떤 사건이 자기 자신을 포함하고 다시 자기 자신을 사용하여 정의될 때 재귀적(recursive)이라고 한다. 자기를 포함한 것

하나의 함수에서 자신을 다시 호출하여 작업을 수행하는 방식으로 주어진 문제를 푸는 방법이다. 재귀 호출이나 되부름이라고도 한다.

- 재귀함수 설계 시에는 입력값이 종료 조건으로 수렴하는지를 꼭 검증해야 한다.

[참고]
https://www.secmem.org/blog/2021/07/09/recursion/

- 비유를 통한 이해

프로그램이 실행되는 전체 과정을 공장의 생산 라인에서 여러 직원들이 제품을 생산하는 과정으로 비유해 보겠습니다.  
그러면 프로그램의 입력은 곧 제품의 기초 재료가 되고, 소스 코드는 직원들의 매뉴얼에 비유할 수 있습니다. 각 직원은 하나의 함수를 담당한다고 가정하겠습니다. 그러면 프로그램이 실행되는 흐름은 다음과 같아집니다.

프로그램에 들어온 입력을 (생산 라인에 들어온 기초 재료를) 여러 함수들이 (여러 직원들이) 순차적으로 처리하여 (순차적으로 가공하여) 정답을 구해내는 (제품을 완성하는) 과정
그러면 이제 프로그램의 실행 과정에 재귀 함수가 포함되는 경우를 추가해 봅시다. 이를 생산 라인에 비유하기 위해, 직원을 다음과 같이 조금 더 명확히 재정의 해보겠습니다.

매뉴얼에 적힌 내용대로 실제로 일을 하는 주체
중요한 것은 소스 코드는 그저 매뉴얼에 불과하다는 사실입니다. 즉, 매뉴얼은 하나만 있지만 같은 매뉴얼대로 작업하는 직원은 여럿이 될 수도 있습니다. 이것이 재귀 함수를 이해하는 첫 단계입니다.

하나의 매뉴얼이라고 하더라도 세부적인 작업 내용은 정확히 그 직원이 이전 단계로부터 넘겨받은 재료의 상태에 따라 달라질 수 있습니다. 이렇게 이전 단계로부터 넘겨받은 재료는 곧 함수의 인자 (또는 전역 변수)가 됩니다.

즉, 재귀 호출은 다음과 같이 비유할 수 있습니다.

한 직원이 자신과 같은 매뉴얼에 따라 작업하는 다른 직원에게 특정 상태의 재료들을 건네며 작업을 요청하고 그 결과물을 돌려받는 과정
한 가지 더 눈여겨볼 점은 여기서는 오로지 순차적인 작업만을 가정하고 있기 때문에 직원 A가 직원 B에게 일을 넘겼다면 B가 일을 모두 마치고 결과물을 A에게 돌려주기 전까지 A는 아무것도 하지 않는다는 점입니다.   

**즉, A는 B가 최종적으로 만들어 낸 결과물만이 필요할 뿐 그 사이에 무슨 일이 일어나는지에 대해서는 전혀 신경쓰지 않아도 됩니다.**

<br>

## 재귀의 특성

재귀는 같은 일을 하는 함수끼리 상태만 달리해서 호출하는 것이다.
재귀 호출된 함수가 무슨 일들을 했는지는 중요하지 않다. 
(예를 들면 그 안에서 또 어떤 재귀 호출들이 있었는지)  
그것이 어떤 결과를 돌려주는지만이 중요하다.
재귀를 사용하는 함수는 반드시 재귀 호출을 하지 않는 경우 (기저 케이스)를 하나 이상 포함해야 한다. 그러지 않으면 재귀 호출이 무한히 발생하게 된다.

<br>

## 피보나치수열

[참고]
https://velog.io/@beton/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%ED%98%95%ED%83%9C%EB%A1%9C-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4-%EA%B5%AC%ED%95%98%EA%B8%B0

0과 1로 시작하고  n번째 피보나치 수는 바로 직전의 두 피보나치 수의 합이다.

5번째 피보나치 수 5가 나온 과정
> 0  
0 + 1 = 1  
1 + 1 = 2  
1 + 2 = 3  
2 + 3 = 5   

즉 다섯 번째 피보나치 수인 5는 다섯 번째 수는 네 번째수와 세 번째 수의 합이고, 네 번째 수는 세 번째 수와 두 번째 수의 합이 된다.

> n = (n-1) + (n-2)  
(n-1) = (n-2) + (n-3)  
(n-2) = (n-3) + (n-4)  

<img src='https://velog.velcdn.com/images%2Fbeton%2Fpost%2Fdeebc09c-f8b7-4073-9ab3-3ec963eee03b%2F1111111.png'>

<br>
<br>
<br>

# 피보나치 수열 함수식
```
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

## 그림 과정
<img src='https://velog.velcdn.com/images%2Fbeton%2Fpost%2F8fe44bad-711c-45de-adfb-42d4d1b81440%2F2222222.png'>

위의 조건이 될 때까지 함수는 계속해서 실행이 되고, 함수가 반복 실행을 멈추는 순간부터 뒤에서부터 순차적으로 (n-1) + (n-2)의 값을 구하게 된다.