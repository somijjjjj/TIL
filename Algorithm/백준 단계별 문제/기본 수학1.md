# Index
- [No.1712 _ 손익분기점](#no1712--손익분기점)
- [No.2292 _ 벌집](#no2292--벌집)
- [No.1193 _ 분수찾기](#no1193--분수찾기)\
- [No.2869 _ 달팽이는 올라가고 싶다](#no2869--달팽이는-올라가고-싶다)
- [No.10250 _ ACM 호텔](#no10250--acm-호텔)
- [No.2775 _ 부녀회장이 될테야](#no2775--부녀회장이-될테야)
- [No.2839 _ 설탕 배달](#no2839--설탕-배달)
- [No.10757 _ 큰 수 A+B](#no10757--큰-수-ab)

--- 

# No.1712 _ 손익분기점
- 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용
- 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다
- 노트북 가격이 C만원으로 책정되어 있고 생산대수를 늘려가다 보면 어느 순간 총 수입이 총 비용(고정+가변)보다 많아지게 되는데
- 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점이라 함
- A, B, C가 주어졌을 때 손익분기점을 구하는 프로그램
- 최초 이익이 발생하는 판매량 출력, 손익분기점이 존재하지 않으면 -1 출력

```
A, B, C = map(int, input().split())

if B>=C:
    print(-1)
else:
    print(int(A/(C-B)+1))
```
- 생산하는 대 수를 n이라고 하면 A+B*n = C*n 일 때 수입과 비용이 같아지기 때문에 B>=C 일 경우 손익분기점이 나타나지 않게 되므로 먼저 조건으로 걸러낸다
- 생산되는 대 수가 늘어날 때마다 C와 B의 차이만큼 수입과 비용의 차이가 줄어들게 되고 A/(C-B)대 생산했을 때 수입과 비용이 같아지기 때문에 +1부터 수입이 많아지게 됨

# No.2292 _ 벌집
- 육각형으로 이루어진 벌집에 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호로 주소로 매길 수 있다
- 숫자 n이 주어졌을 때 벌집의 중앙 1에서 n번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함)를 계산하는 프로그램

```
n = int(input())

nums_pileup = 1  # 벌집의 개수, 1개부터 시작
cnt = 1
while n > nums_pileup :
    nums_pileup += 6 * cnt  # 벌집이 6의 배수로 증가
    cnt += 1  # 반복문을 반복하는 횟수
print(cnt)
```
- 랜덤으로 n이 주어질 때 1이 있는 벌집 위치에서 숫자 n까지 거쳐가는 단계 수를 찾아내는 문제
- 숫자 n이 벌집에서 몇 겹째에 있는지를 출력하는 문제
- 벌집 모양을 보면 벌집의 개수가 6의 배수로 증가하며 규칙성 있게 한 겹씩 쌓이는 점을 이용해 while문이 반복하면서 6의 배수로 증가하는 코드를 작성
- while문은 증가하는 숫자가 입력받은 수인 n에 도다할 때까지만 반복하고 반복문이 반복되는 동안에 반복 횟수를 카운트해서 카운트 숫자를 출력

# No.1193 _ 분수찾기
- 이와 같이 나열된 분수들을 1/1 → 1/2 → 2/1 → 3/1 → 2/2 → … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.
- X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.

```
input_num = int(input())

line = 0  # 사선 라인
max_num = 0  # 입력된 숫자(input_num 변수)의 라인에서 가장 큰 숫자
while input_num > max_num:
    line += 1  
    max_num += line  

gap = max_num - input_num 
if line % 2 == 0:  # 사선 라인이 짝수번째 일 때
    top = line - gap  #분자
    under = gap + 1  #분모
else :  # 사선 라인이 홀수번째 일 때
    top = gap + 1  #분자
    under = line - gap  #분모
print(f'{top}/{under}')
```
- 사선 라인이 짝수번째인지 홀수번째인지에 따라 입력받는 수에 대응하는 분수를 찾는 규칙이 달라지는 점을 이용
- while 반복문으로 입력받은 숫자가 몇 번째 사선 라인에 있는지 확인
- line변수는 입력받은 정수가 몇 번째 라인에 있는지 알아내는데 사용, max_num은 입력받은 정수가 있는 사선라인에 위치한 정수 중 가장 큰 정수를 찾는데 사용
- 점점 커지는 max_num이 input_num보다 커지면 반복문을 중단하도록 함
- 사선라인이 짝수번째이면 오른쪽 끝에서 왼쪽 아래 사선 방향으로 숫자가 커지고, 사선 라인이 홀수번째이면 왼쪽 끝에서부터 오른쪽 위 사선 방향으로 숫자가 커진다.
- 정수의 배열을 이용해서 분수의 분자 분모를 구하는 식 작성
- 사선라인에서 가장 큰 수를 입력받은 수를 빼는 방법으로 gap변수를 구함
- gap변수에 1을 더한 값과 line변수에서 gap변수를 뺀 값을 이용해서 분자 분모를 구함
- 사선 라인이 짝수일 때와 홀 수 일 때에 이 분자 분모에 해당하는 식을 반대로 대입해주어서 문제를 풀수있음


# No.2869 _ 달팽이는 올라가고 싶다
- 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다
- 낮에는 A미터 올라갈 수 있고 밤에 잠을 자는동안 B미터 미끄러짐
- 정상에 올라간 후에는 미끄러지 않음
- 달팽이가 나무 막대를 모두 올라가려면 며칠이 걸리는지 구하는 프로그램

```
import math

a, b, v = map(int, input().split())

day = (v - b) / (a - b)
print(math.ceil(day))
```
- a= 올라가는 길이, b= 떨어지는길이, v= 나무높이 
- a만큼 올랐다 b만큼 떨어지기를 반복하기 때문에 a-b 거리 만큼 올라가는 것을 n만큼 반복하고 정상에 한번 도달하면 밤에 미끄러지지 않는 것을 고려함
- math 모듈을 사용해서 올림 처리 

# No.10250 _ ACM 호텔
- 각 층의 w개의 방이 있는 h층 건물(1 <= h <= 99), 엘리베이터는 가장 왼쪽, 정문은 일층 엘리베이터 바로 앞, 모든 인접한 두 방 사이의 거리는 같은 거리라고 가정, 호텔의 정면 쪽에만 방이 있다고 가정한다
- 방 번호는 yxx 나 yyxx 형태인데 y는 층수를 나타내고 x는 엘리베이터에서부터 세었을 때의 번호
- 걷는 거리가 같을 때에는 아래층의 방을 더 선호한다. 102호보다 2101호를 선호
- n번째로 도착한 손님에게 배정될 방 번호를 계산하는 프로그램
- 테스트케이스 t, 호텔층수h, 각층의 방수w, 몇번째 손님n

```
t = int(input())

for i in range(t):
    h, w, n = map(int, input().split())
    num = n//h + 1
    floor = n % h

    if n % h == 0:  # h의 배수이면,
        num = n//h
        floor = h

    print(f'{floor*100+num}')
```
- 문제는 1호실의 1층부터 h층 까지 채워지면 2호실의 1층부터 h층까지 채워지는 방식이다
- 손님이 방문한 순서 n과 객실 호수의 규칙성을 찾아보면 층수는 n에서 건물 층수를 나눈 나머지가 되고 호수는 n에서 건물 층수를 나눈 몫 ++1이 된다.
- 만약 n이 건물 층수의 배수인 경우 층수는 입력받은 층 수 그대로가 되고, 호수는 n에서 건물 층수를 나눈 몫이 된다.
- print함수로 출력문을 작성할 때에는 위에서 작성한 for문에서 층과 호를 각각 구했기때문에 floor변수에 100을 곱하고 그 수에 num변수를 더한 값을 출력한다.

# No.2775 _ 부녀회장이 될테야
- a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다라는 계약 조항이 있다
- 아파트에 비어있는 집은 없고 모든 거주민들이 이 계약조건을 지키고 왓다고 가정, 주어지는 양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력, 단 아파트는 0층부터 있고 각층에는 1호부터 있으며 0층의 i호에는 i명이 산다

```
t = int(input())

for _ in range(t):  # 테스트 케이스 수
    k = int(input())  # 층
    n = int(input())  # 호
    
    f0 = [x for x in range(1, n+1)]  # 0층 리스트(1,2,3)
    for k in range(k):  # 층 수 만큼 반복 
        for i in range(1, n):  # 1 ~ n-1까지 (인덱스로 사용) (1,2)
            f0[i] += f0[i-1]  # 층별 각 호실의 사람 수를 변경 
            # 1 : 1(2) + 0(1) = 3
            # 2: 2(3) + 1(3) = 6 
            # k2 =  1 : 3 + 1 
            # k2 =  2 : 6 + 4
    print(f0[-1])  # 가장 마지막 수 출력 
```
- 호수별로 사람 수가 증가하는데에 동일한 규칙성이 없기 때문에 0층부터 입력받는 층수까지 한층 한층 사람 수를 더해가는 방식으로 풀이
- for문을 통해 테스트케이스별로 층 k, 호 n을 입력받는다
- 0층의 1호부터 입력받은 n호까지 거주자 수 리스트를 생성
- comprehension 표현식을 이용하여 숫자 리스트 생성
- 첫번째 for문은 입력받은 k층 수 만큼 반복하고 두번째 for문은 각 층의 1호부터 n호까지 숫자를 반복하여 f0 리스트의 인덱스로 사용
- for문의 숫자 인덱스를 이용하여 이전 인덱스의 숫자를 더한 값을 리셋. 층 수가 증가할 때마다 한층 아래층의 이전 호실에 사는 사람의 숫자를 더하는 것과 같은 의미
- 반복문이 종료됐을 때 가장 마지막 수를 호출하면 입력받은 층, 호수에 해당하는 사람 수를 출력할 수 있음

# No.2839 _ 설탕 배달
- 설탕은 봉지에 담겨져있고 3킬로그램 봉지와 5킬로그램 봉지가 있다
- 설탕을 정확하게 n킬로그램 배달해야 할 때, 최대한 적은 봉지를 들고 가려면 봉지 몇 개를 가져가면 되는지 구하는 프로그램
- 정확하게 n킬로그램을 만들 수 없으면 -1 출력

```
sugar = int(input())

bag = 0
while sugar >= 0 :
    if sugar % 5 == 0 :  # 5의 배수이면
        bag += (sugar // 5)  # 5로 나눈 몫을 구해야 정수가 됨
        print(bag)
        break
    sugar -= 3
    bag += 1  # 5의 배수가 될 때까지 설탕-3, 봉지+1
else :
    print(-1)
```
- 설탕 봉지 개수를 찾는 코드는 while 반복문을 활용
- 5의 배수가 될 때까지 설탕의 무게에서 3씩 빼가는 방식으로 딱 나누어 떨어지지 않을 때는 while-else문을 활용해서 -1을 출력
- 봉지의 수는 변수 bag에 0을 선언
- while문은 입력받은 sugar의 수가 0보다 같거나 클때까지만 반복
- 음수가 되면 설탕 봉지수가 입력받은 설탕 무게에 정확하게 나누어 떨어지지 않는 것이기 때문에 else문으로 내려감
- 봉지의 개수를 최소화 하기 위해 if조건식을 이용해서 5의 배수가 되면 while 봉지의 개수를 출력하고 while문을 끝나도록 break 걸었음
- 이때 bag의 수는 sugar변수를 5로 나눈 몫으로 계산
- 5의 배수가 아닐 때는 5의 배수가 될 때까지 3을 빼고 bag의 개수는 1을 더함

# No.10757 _ 큰 수 A+B
- 두 정수 A, B를 입력받은 다음 A+B를 출력하는 프로그램을 작성하시오

```
A, B = map(int, input().split())
print(A+B)
```
- 숫자가 지나치게 클 경우 C언어는 메모리에 담지 못하고 에러를 출력하지만 파이썬은 괜찮음