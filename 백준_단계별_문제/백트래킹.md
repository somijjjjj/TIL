# 백트래킹

- [No.15649 N과 M (1)](#no15649-n과-m-1)
- [No.15650 N과 M (2)](#no15650-n과-m-2)
- [No.15651 N과 M (3)](#no15651-n과-m-3)
- [No.15652 N과 M (4)](#no15652-n과-m-4)
- [No.9663 N-Queen](#no9663-n-queen)
- [No.2580 스도쿠](#no2580-스도쿠)
- [No.14888 연산자 끼워넣기](#no14888-연산자-끼워넣기)
- [No.14889 스타트와 링크](#no14889-스타트와-링크)

---

# No.15649 N과 M (1)

## 문제

- 자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램
- 1부터 N까지 자연수 중에서 중복없이 M개를 고른 수열

### 입력

1. N과 M이 주어진다.

### 출력
- 한줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 
- 공백으로 구분해서 출력
- 수열은 사전 순으로 증가하는 순서로 출력

## 풀이

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())

s = []

def dfs():
    if len(s) == m:
        print(' '.join(map(str, s)))
        return

    for i in range(1, n+1):
        if i not in s:
            s.append(i)
            dfs()
            s.pop()
dfs()
```

- [풀이참고](https://jiwon-coding.tistory.com/21)
- 재귀함수를 이용하여 m개의 수열을 저장하기 위한 리스트 s를 만든다.
- 리스트에 들어간 수열의 개수가 m개가 되면 리스트에 있는 숫자를 출력하고 함수를 탈출한다.
- for문을 이용하여 1부터 n까지 숫자들을 모두 확인하며 리스트 s에 없다면,
- 현재 수(i)를 s에 저장하고, 재귀함수를 호출한다. 그렇게 m개의 수열을 저장하고 나면 마지막 수를 pop하고 다음 숫자를 넣으며 함수가 진행된다.


<br>
<br>

# No.15650 N과 M (2)

## 문제

- 자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이 M인 수열을 모두 구하는 프로그램
- 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
- 고른 수열은 오름차순이어야 한다.

### 입력

1. 자연수 N, M (1 <= M <= N <= 8)

### 출력

1. 한 줄에 하나씩 문제의 조건을 만족하는 수열을 공백으로 구분해서 출력
    - 중복되는 수열을 여러 번 출력하면 안되고, 사전 순으로 증가하는 순서로 출력

## 풀이

- 순서 상관없이 중복되는 수열은 출력하면 안된다.

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())

result = []

def back(start):
    if len(result) == m:
        print(' '.join(map(str, result)))
        return

    for i in range(start, n+1):

        if i not in result:
            result.append(i)
            back(i+1)
            result.pop()
back(1)
```

- 1부터 n까지 수에서 m개가 되는 수열을 탐색한다. 하지만, 2 1 과 1 2는 중복으로 보기때문에 한 번만 출력을 해야한다.
- back함수 파라미터로 start를 1부터 탑색을 시작한다. 1부터 n까지 변수i에 하나씩 수열을 추가하고, 이때 재귀함수를 통해 i+1번째부터 n까지 두번째 자리에 추가할 수열을 탐색한다.
- result(수열)이 m가 되었을 때 조건에 만족하므로 해당 수열을 출력하고 재귀함수를 탈출한다.
- 탈출하고나면 pop을 통해 마지막 수를 제거한 뒤 진행한다. 


<br>
<br>

# No.15651 N과 M (3)

## 문제

- 자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이 M인 수열을 모두 구하는 프로그램
- 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
- 같은 수를 여러번 골라도 된다.

### 입력

1. 자연수 N, M (1 <= M <= N <= 7)

### 출력

1. 한 줄에 하나씩 문제의 조건을 만족하는 수열을 공백으로 구분해서 출력
    - 중복되는 수열을 여러 번 출력하면 안되고, 사전 순으로 증가하는 순서로 출력

## 풀이

- 1 1, 2 2, 3 3, 4 4 와 같이 똑같은 수를 골라도 된다.

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())

result = []

def back():
    if len(result) == m:
        print(' '.join(map(str, result)))
        return

    for i in range(1, n+1):
        result.append(i)
        back()
        result.pop()
        
back()
```

- for문을 통해 1부터 n까지 수열에 들어갈 숫자를 탐색한다. 
- result(수열)에 숫자(i)를 추가하고, 다음 숫자를 재귀함수를 통해 추가한다.
- 수열의 길이가 m이 되었을 때, 조건에 만족했으므로 출력하고 재귀함수를 탈출한다.
- 탈출 전 마지막 숫자는 pop을 통해 제거하고 다음 수열을 탐색한다.

<br>
<br>

# No.15652 N과 M (4)


## 문제

- 자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이 M인 수열을 모두 구하는 프로그램
- 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
- 같은 수를 여러번 골라도 된다.
- 고른 수열은 비내림차순이어야 한다.
    - 길이가 K인 수열 A가  $A_1 ≤ A_2 ≤ ... ≤ A_{K-1} ≤ A_K$를 만족하면, 비내림차순이라고 한다.

### 입력

1. 자연수 N, M (1 <= M <= N <= 7)

### 출력

1. 한 줄에 하나씩 문제의 조건을 만족하는 수열을 공백으로 구분해서 출력
    - 중복되는 수열을 여러 번 출력하면 안되고, 사전 순으로 증가하는 순서로 출력

## 풀이

- 중복된 수열은 출력하면 안되고, 오름차순으로 출력하라는 의미

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())

result = []

def back(start):
    if len(result) == m:
        print(' '.join(map(str, result)))
        return

    for i in range(start, n+1):
        result.append(i)
        back(i)
        result.pop()

back(1)
```

- 1부터 n까지 수 중에서 m개의 수열을 탐색하기 위해 back()함수의 start파라미터를 1로 시작한다.
- start부터 n까지 수열(result)에 추가하며 m개의 수열을 만족하면 출력한 뒤 재귀함수를 탈출한다.
- 처음 1부터 시작하여 다음 자리도 해당 i부터 시작하는 재귀함수를 시작한다. 
- 같은 수를 여러번 고르며 중복된 수열은 피할 수 있고, 작은 수부터 순서대로 오름차순으로 수열을 구할 수 있다.

<br>
<br>

# No.9663 N-Queen

## 문제
NxN인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.
N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램

### 입력
1. N

## 풀이

- 퀸은 상하좌우, 대각선 4방향으로 거리 제한 없이 움직일 수 있다.
- 서로의 퀸이 움직이는 경로에 다른 퀸이 있어서는 안 된다.
- 상태공간트리를 구성하여 DFS로 퀸을 놓을 수 있는지 탐색한다.

> 참고영상 : https://www.youtube.com/watch?v=z4wKvYdd6wM

- 조건
1. 같은 열인지 체크한다.
2. 대각선을 체크한다.(행의 차이의 절댓값 == 열의 차이의 절댓값)
    - 퀸2[행] - 퀸1[행] == 퀸2[열] - 퀸1[열]


```python
import sys
input = sys.stdin.readline

n = int(input())

result = 0
row = [0] * n # n 크기의 빈리스트
visit = [False] * n # 방문체크

def n_queens (i):
    global result

    if i == n : # i 갯수가 n과 같으면 result +1
        result += 1
        return
    else:
        for j in range(n): # n개의 열

            if visit[i]: 
                continue

            row[i] = j # [i, j] 퀸
            if promising(i): # 퀸 자리 찾기 True
                visit[i] = True
                n_queens(i+1) # promising True이면 다음 행
                visit[i] = False

def promising (i):
    for j in range(i): # 같은 행, 같은 열, 대각선 위치했는지 확인
        if row[i] == row[j] or abs(row[i] - row[j]) == abs(i - j):
            return False

    return True

n_queens(0)
print(result)
```

- 처음 n을 입력받으면 n크기의 빈리스트 row를 생성한다.
- n_gueens 함수는 각 행마다 열 자리를 탐색하며 promising이 True이면 다음 행으로 계속 진행한다.
- promising 함수는 퀸이 들어갈 수 있는 자리인지 확인한다. 
- 탐색이 완료되면 result에 +1 씩 추가하여 퀸이 들어갈 수 있는 자리를 count하여 출력한다.

> 시간초과 발생하여 방문체크 추가, pypy3 제출  
참고 블로그 : https://velog.io/@uoayop/BOJ-9663-N-Queen-Python

<br>
<br>

# No.2580 스도쿠

<br>
<br>

# No.14888 연산자 끼워넣기

<br>
<br>

# No.14889 스타트와 링크

<br>
<br>


